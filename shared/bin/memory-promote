#!/usr/bin/env python3
"""
memory-promote — Automated memory tier promotion.

Lifecycle: raw (daily) → structured (facts + graph) → curated (MEMORY.md)

Runs after distillation. Checks what was captured in the current session
and ensures it flows to the right tier:
  - Facts → facts.jsonl (if not already there)
  - Entities/relations → aletheia graph (if not already there)
  - Significant decisions/lessons → MEMORY.md candidates file
  - Stale facts → confidence decay

Usage:
    memory-promote --nous syn          # Promote for a specific nous
    memory-promote --nous syn --dry    # Show what would promote
"""

import argparse
import json
import os
import re
import subprocess
import sys
from datetime import datetime, timedelta
from pathlib import Path

ALETHEIA_ROOT = Path(os.environ.get("ALETHEIA_ROOT", "/mnt/ssd/aletheia"))
SHARED = ALETHEIA_ROOT / "shared"


def get_recent_daily_files(nous_id: str, days: int = 3) -> list:
    """Get recent daily memory files."""
    memory_dir = ALETHEIA_ROOT / "nous" / nous_id / "memory"
    files = []
    today = datetime.now()
    for i in range(days):
        date = today - timedelta(days=i)
        path = memory_dir / f"{date.strftime('%Y-%m-%d')}.md"
        if path.exists():
            files.append(path)
    return files


def get_session_state(nous_id: str) -> dict:
    """Read current session state."""
    state_path = ALETHEIA_ROOT / "nous" / nous_id / "memory" / "session-state.yaml"
    if not state_path.exists():
        return {}
    try:
        # Simple YAML-ish parsing (avoid dependency)
        state = {}
        with open(state_path) as f:
            for line in f:
                line = line.strip()
                if ":" in line and not line.startswith("#"):
                    key, _, val = line.partition(":")
                    state[key.strip()] = val.strip().strip('"')
        return state
    except Exception:
        return {}


def get_existing_facts() -> set:
    """Get existing fact subjects for dedup."""
    facts_path = SHARED / "memory" / "facts.jsonl"
    subjects = set()
    if facts_path.exists():
        with open(facts_path) as f:
            for line in f:
                if line.strip():
                    try:
                        fact = json.loads(line)
                        subjects.add(f"{fact.get('subject', '')}-{fact.get('predicate', '')}")
                    except json.JSONDecodeError:
                        pass
    return subjects


def extract_promotable_items(content: str) -> dict:
    """Extract items from daily notes that should be promoted."""
    items = {
        "decisions": [],
        "lessons": [],
        "corrections": [],
        "facts": [],
    }

    for line in content.split("\n"):
        line_stripped = line.strip().lstrip("- ")
        lower = line_stripped.lower()

        # Decisions
        if any(w in lower for w in ["decided", "decision:", "chose to", "choosing"]):
            items["decisions"].append(line_stripped)

        # Lessons
        if any(w in lower for w in ["lesson:", "learned:", "takeaway:", "insight:", "realized"]):
            items["lessons"].append(line_stripped)

        # Corrections
        if any(w in lower for w in ["corrected:", "correction:", "wrong about", "mistake:"]):
            items["corrections"].append(line_stripped)

    return items


def promote(nous_id: str, dry_run: bool = False):
    """Run the promotion pipeline."""
    print(f"Memory promotion for {nous_id}")
    print(f"{'DRY RUN — ' if dry_run else ''}Checking recent memory...")

    # 1. Get recent daily files
    daily_files = get_recent_daily_files(nous_id)
    if not daily_files:
        print("  No recent daily files found")
        return

    # 2. Extract promotable items
    all_items = {"decisions": [], "lessons": [], "corrections": [], "facts": []}
    for f in daily_files:
        content = f.read_text()
        items = extract_promotable_items(content)
        for key in all_items:
            all_items[key].extend(items[key])

    total = sum(len(v) for v in all_items.values())
    print(f"  Found {total} promotable items from {len(daily_files)} files:")
    for key, items in all_items.items():
        if items:
            print(f"    {key}: {len(items)}")
            for item in items[:3]:
                print(f"      → {item[:80]}")

    if total == 0:
        print("  Nothing to promote")
        return

    # 3. Write promotion candidates
    candidates_path = ALETHEIA_ROOT / "nous" / nous_id / "memory" / "promotion-candidates.md"
    if not dry_run:
        with open(candidates_path, "w") as f:
            f.write(f"# Promotion Candidates — {datetime.now().strftime('%Y-%m-%d')}\n\n")
            f.write("*Items extracted from recent daily notes for potential MEMORY.md promotion.*\n\n")
            for key, items in all_items.items():
                if items:
                    f.write(f"## {key.title()}\n\n")
                    for item in items:
                        f.write(f"- {item}\n")
                    f.write("\n")
        print(f"  Candidates written to {candidates_path.name}")

    # 4. Graph promotion: add decisions and lessons as graph nodes
    if not dry_run:
        for decision in all_items["decisions"][:5]:
            try:
                subprocess.run(
                    ["aletheia-graph", "add",
                     nous_id, "DECIDED", decision[:100],
                     "--nous", nous_id],
                    capture_output=True, timeout=10
                )
            except Exception:
                pass

        for lesson in all_items["lessons"][:5]:
            try:
                subprocess.run(
                    ["aletheia-graph", "add",
                     nous_id, "LEARNED", lesson[:100],
                     "--nous", nous_id],
                    capture_output=True, timeout=10
                )
            except Exception:
                pass

        for correction in all_items["corrections"][:5]:
            try:
                subprocess.run(
                    ["aletheia-graph", "add",
                     nous_id, "LEARNED", f"Correction: {correction[:90]}",
                     "--nous", nous_id],
                    capture_output=True, timeout=10
                )
            except Exception:
                pass

    print("  Done")


def main():
    parser = argparse.ArgumentParser(description="Memory tier promotion")
    parser.add_argument("--nous", required=True, help="Nous ID")
    parser.add_argument("--dry", action="store_true", help="Dry run")
    args = parser.parse_args()

    promote(args.nous, dry_run=args.dry)


if __name__ == "__main__":
    main()
