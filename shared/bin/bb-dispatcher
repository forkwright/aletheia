#!/usr/bin/env bash
source /mnt/ssd/aletheia/shared/config/aletheia.env 2>/dev/null || true
# bb-dispatcher - Watches blackboard and notifies agents of pending tasks
# Triggered by systemd path unit when tasks.jsonl changes

set -euo pipefail

ALETHEIA_ROOT="${ALETHEIA_ROOT:-${ALETHEIA_ROOT:-/mnt/ssd/aletheia}}"
BB_DIR="$ALETHEIA_ROOT/shared/blackboard"
TASKS_FILE="$BB_DIR/tasks.jsonl"
DISPATCH_LOG="$BB_DIR/dispatch.log"
LAST_DISPATCH="$BB_DIR/.last_dispatch"

log() {
  echo "$(date -Iseconds) $1" >> "$DISPATCH_LOG"
}

# Get pending tasks that haven't been dispatched
get_pending_tasks() {
  if [[ ! -s "$TASKS_FILE" ]]; then
    return
  fi
  
  # Merge all updates, find pending tasks
  jq -s '
    group_by(.id) | 
    map(reduce .[] as $item ({}; . * $item)) |
    .[] | 
    select(.status == "pending")
  ' "$TASKS_FILE"
}

# Map agent to Clawdbot session
get_session_for_agent() {
  local agent="$1"
  case "$agent" in
    syl) echo "agent:syl:main" ;;
    chiron) echo "agent:chiron:main" ;;
    eiron) echo "agent:eiron:main" ;;
    demiurge) echo "agent:demiurge:main" ;;
    syn|any|*) echo "agent:main:main" ;;
  esac
}

# Notify agent via Clawdbot sessions_send
notify_agent() {
  local agent="$1"
  local task_id="$2"
  local title="$3"
  local from="$4"
  local priority="$5"
  
  local session
  session=$(get_session_for_agent "$agent") || return 1
  local message="ðŸ“‹ **Blackboard Task** [${priority^^}]
From: $from
Task: $title

Claim with: \`bb claim ${task_id:0:8}\`"

  log "Notifying $agent ($session) about task ${task_id:0:8}"
  
  # Use openclaw API to send to session
  # If agent doesn't have active session, this queues for next wakeup
  curl -s -X POST "http://localhost:18789/api/sessions/send" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $(cat /home/syn/.openclaw/gateway-token 2>/dev/null || echo '')" \
    -d "{
      \"sessionKey\": \"$session\",
      \"message\": $(echo "$message" | jq -Rs .)
    }" > /dev/null 2>&1 || log "Failed to notify $agent"
}

# Mark task as dispatched (so we don't re-notify)
mark_dispatched() {
  local task_id="$1"
  echo "$task_id" >> "$LAST_DISPATCH"
}

is_dispatched() {
  local task_id="$1"
  grep -q "^$task_id$" "$LAST_DISPATCH" 2>/dev/null
}

# Main dispatch logic
main() {
  touch "$LAST_DISPATCH"
  
  local pending
  pending=$(get_pending_tasks) || exit 1
  
  if [[ -z "$pending" ]]; then
    exit 0
  fi
  
  # Process each pending task
  echo "$pending" | jq -c '.' | while read -r task; do
    local id
    id=$(echo "$task" | jq -r '.id') || continue
    local to
    to=$(echo "$task" | jq -r '.to') || continue
    local title=$(echo "$task" | jq -r '.title')
    local from=$(echo "$task" | jq -r '.from')
    local priority=$(echo "$task" | jq -r '.priority')
    
    # Skip if already dispatched
    if is_dispatched "$id"; then
      continue
    fi
    
    # Skip broadcast/any tasks (Syn handles those in heartbeat)
    if [[ "$to" == "any" || "$to" == "broadcast" ]]; then
      continue
    fi
    
    # Notify the target agent
    notify_agent "$to" "$id" "$title" "$from" "$priority"
    mark_dispatched "$id"
    
    log "Dispatched task $id to $to"
  done
}

main "$@"
