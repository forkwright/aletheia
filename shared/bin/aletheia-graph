#!/usr/bin/env python3
# aletheia-graph â€” Shared awareness layer via Neo4j

"""
Usage:
  aletheia-graph add <subject> <relation> <object> [--nous AGENT] [--domain DOMAIN]
  aletheia-graph query <cypher>
  aletheia-graph recent [--hours 24] [--nous AGENT]
  aletheia-graph connections <entity>
  aletheia-graph stats
  aletheia-graph propagate --from AGENT
"""

import argparse
import sys
from datetime import datetime

from neo4j import GraphDatabase

NEO4J_URI = "neo4j://localhost:7687"
NEO4J_USER = "neo4j"
NEO4J_PASSWORD = "aletheia-memory"


def get_driver():
    return GraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASSWORD))


def run_query(cypher, **params):
    driver = get_driver()
    try:
        with driver.session() as session:
            result = session.run(cypher, **params)
            return [dict(record) for record in result]
    except Exception as e:
        return f"ERROR: {e}"
    finally:
        driver.close()


def format_results(records):
    if isinstance(records, str):
        return records
    if not records:
        return "(no results)"
    lines = []
    for rec in records:
        parts = [str(v) for v in rec.values()]
        lines.append(" | ".join(parts))
    return "\n".join(lines)


def ensure_schema():
    queries = [
        "CREATE INDEX entity_name IF NOT EXISTS FOR (n:`__Entity__`) ON (n.name)",
        "CREATE INDEX entity_domain IF NOT EXISTS FOR (n:`__Entity__`) ON (n.domain)",
    ]
    driver = get_driver()
    try:
        with driver.session() as session:
            for q in queries:
                try:
                    session.run(q)
                except Exception:
                    pass
    finally:
        driver.close()


def add_knowledge(subject, relation, obj, agent="unknown", domain="shared", confidence=0.8, evidence=""):
    ensure_schema()
    ts = int(datetime.now().timestamp())
    rel_type = relation.upper().replace(" ", "_").replace("-", "_")

    cypher = (
        "MERGE (s:`__Entity__` {name: $subject}) "
        "ON CREATE SET s.domain = $domain "
        "MERGE (o:`__Entity__` {name: $object}) "
        "ON CREATE SET o.domain = $domain "
        f"CREATE (s)-[r:{rel_type} {{"
        "agent: $agent, domain: $domain, "
        "confidence: $confidence, timestamp: $ts, "
        "evidence: $evidence"
        "}]->(o) "
        "RETURN s.name, type(r), o.name"
    )
    results = run_query(cypher, subject=subject, object=obj, agent=agent,
                        domain=domain, confidence=confidence, ts=ts, evidence=evidence)
    return format_results(results)


def get_connections(entity):
    cypher = (
        "MATCH (n {name: $name})-[r]->(m) "
        "RETURN n.name AS source, type(r) AS relation, m.name AS target, "
        "properties(r).agent AS agent, properties(r).confidence AS confidence "
        "UNION "
        "MATCH (m)-[r]->(n {name: $name}) "
        "RETURN m.name AS source, type(r) AS relation, n.name AS target, "
        "properties(r).agent AS agent, properties(r).confidence AS confidence"
    )
    return format_results(run_query(cypher, name=entity))


def get_recent(hours=24, agent=None):
    cutoff = int(datetime.now().timestamp()) - (hours * 3600)
    if agent:
        cypher = (
            "MATCH (s)-[r]->(o) "
            "WHERE r.timestamp > $cutoff AND r.agent = $agent "
            "RETURN s.name AS source, type(r) AS relation, o.name AS target, "
            "r.agent AS agent, r.timestamp AS ts "
            "ORDER BY r.timestamp DESC LIMIT 20"
        )
        results = run_query(cypher, cutoff=cutoff, agent=agent)
    else:
        cypher = (
            "MATCH (s)-[r]->(o) "
            "WHERE r.timestamp > $cutoff "
            "RETURN s.name AS source, type(r) AS relation, o.name AS target, "
            "r.agent AS agent, r.timestamp AS ts "
            "ORDER BY r.timestamp DESC LIMIT 20"
        )
        results = run_query(cypher, cutoff=cutoff)
    return format_results(results)


def get_stats():
    nodes = run_query("MATCH (n) RETURN count(n) AS count")
    edges = run_query("MATCH ()-[r]->() RETURN count(r) AS count")
    agents = run_query(
        "MATCH ()-[r]->() WHERE r.agent IS NOT NULL "
        "RETURN r.agent AS agent, count(r) AS count ORDER BY count DESC"
    )
    labels = run_query(
        "MATCH (n) UNWIND labels(n) AS label "
        "RETURN label, count(*) AS count ORDER BY count DESC LIMIT 10"
    )

    parts = []
    if isinstance(nodes, list) and nodes:
        parts.append(f"Nodes: {nodes[0].get('count', '?')}")
    if isinstance(edges, list) and edges:
        parts.append(f"Edges: {edges[0].get('count', '?')}")
    if isinstance(agents, list) and agents:
        parts.append("\nBy agent:")
        for r in agents:
            parts.append(f"  {r.get('agent', '?')}: {r.get('count', '?')}")
    if isinstance(labels, list) and labels:
        parts.append("\nBy label:")
        for r in labels:
            parts.append(f"  {r.get('label', '?')}: {r.get('count', '?')}")
    return "\n".join(parts)


def propagate_from(agent):
    cypher = (
        "MATCH (s)-[r]->(o) "
        "WHERE r.agent = $agent AND r.domain <> 'shared' "
        "AND EXISTS { MATCH (o)-[r2]->(x) WHERE r2.agent <> $agent } "
        "SET r.domain = 'shared' "
        "RETURN s.name AS source, type(r) AS relation, o.name AS target"
    )
    return format_results(run_query(cypher, agent=agent))


def main():
    parser = argparse.ArgumentParser(description="Aletheia shared knowledge graph")
    sub = parser.add_subparsers(dest="command")

    add_p = sub.add_parser("add")
    add_p.add_argument("subject")
    add_p.add_argument("relation")
    add_p.add_argument("object")
    add_p.add_argument("--nous", "--agent", default="unknown")
    add_p.add_argument("--domain", default="shared")
    add_p.add_argument("--confidence", type=float, default=0.8)
    add_p.add_argument("--evidence", default="")

    q_p = sub.add_parser("query")
    q_p.add_argument("cypher")

    r_p = sub.add_parser("recent")
    r_p.add_argument("--hours", type=int, default=24)
    r_p.add_argument("--nous", "--agent", default=None)

    c_p = sub.add_parser("connections")
    c_p.add_argument("entity")

    sub.add_parser("stats")

    p_p = sub.add_parser("propagate")
    p_p.add_argument("--from", dest="from_agent", required=True)

    args = parser.parse_args()

    if args.command == "add":
        print(add_knowledge(args.subject, args.relation, args.object,
                            agent=args.nous, domain=args.domain,
                            confidence=args.confidence, evidence=args.evidence))
    elif args.command == "query":
        print(format_results(run_query(args.cypher)))
    elif args.command == "recent":
        print(get_recent(hours=args.hours, agent=args.nous))
    elif args.command == "connections":
        print(get_connections(args.entity))
    elif args.command == "stats":
        print(get_stats())
    elif args.command == "propagate":
        print(propagate_from(args.from_agent))
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
