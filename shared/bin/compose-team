#!/usr/bin/env python3
"""
compose-team — Dynamic agent composition for Aletheia.

Analyzes a task description and returns the optimal team of nous
based on domain relevance and epistemic fit.

Usage:
    compose-team "task description"                    # Recommend team
    compose-team "task description" --execute          # Spawn and run
    compose-team "task description" --deliberate       # Run deliberation
"""

import argparse
import json
import os
import sys
from pathlib import Path

ALETHEIA_ROOT = Path(os.environ.get("ALETHEIA_ROOT", "/mnt/ssd/aletheia"))

# Domain → nous mapping with confidence weights
DOMAIN_MAP = {
    "chiron": {
        "domains": ["work", "sql", "data", "dashboard", "employer", "redshift",
                     "analytics", "roi", "pepm", "healthcare", "claims"],
        "epistemology": "empirical",
        "description": "Measurement and evidence. If it can be quantified, Chiron knows how.",
    },
    "eiron": {
        "domains": ["school", "mba", "homework", "capstone", "academic",
                     "paper", "research", "analysis", "ercot", "macroeconomics"],
        "epistemology": "skeptical",
        "description": "Falsification. Finds what's wrong, what's missing, what doesn't hold.",
    },
    "demiurge": {
        "domains": ["leather", "craft", "ardent", "belt", "dye", "bindery",
                     "stitch", "material", "buckle", "photography", "brand"],
        "epistemology": "material",
        "description": "Embodied practice. Knows through making, through the hand.",
    },
    "syl": {
        "domains": ["partner", "family", "home", "child", "baby",
                     "household", "calendar", "schedule", "grocery"],
        "epistemology": "relational",
        "description": "Systemic impact. How does this affect the people involved?",
    },
    "arbor": {
        "domains": ["tree", "a2z", "adam", "arborist", "business_city",
                     "woodworking", "joinery", "growth"],
        "epistemology": "organic",
        "description": "Growth patterns. What's the natural development path?",
    },
    "akron": {
        "domains": ["truck", "cummins", "ram", "diesel", "radio",
                     "preparedness", "overlanding", "vehicle", "electrical"],
        "epistemology": "reliability",
        "description": "Fail-safe design. What breaks? What's the backup?",
    },
}

# Cross-cutting patterns that benefit from multiple perspectives
MULTI_NOUS_TRIGGERS = {
    "architecture": ["chiron", "eiron"],    # Build + critique
    "quality": ["demiurge", "chiron"],       # Craft + measurement
    "planning": ["eiron", "akron"],          # Analysis + reliability
    "cost": ["chiron", "demiurge"],          # Data + material reality
    "family": ["syl", "demiurge"],           # Relationships + practical
    "decision": ["eiron", "chiron"],         # Skepticism + evidence
    "system": ["chiron", "akron"],           # Data + reliability
    "creative": ["demiurge", "arbor"],       # Making + growth
    "emergency": ["akron", "syl"],           # Reliability + impact
}


def score_nous(task: str) -> list:
    """Score each nous for relevance to the task."""
    task_lower = task.lower()
    scores = {}

    for nous_id, config in DOMAIN_MAP.items():
        score = 0
        matched = []

        # Domain keyword matching
        for domain in config["domains"]:
            if domain in task_lower:
                score += 2
                matched.append(domain)

        # Cross-cutting pattern bonus
        for pattern, team in MULTI_NOUS_TRIGGERS.items():
            if pattern in task_lower and nous_id in team:
                score += 1.5
                matched.append(f"pattern:{pattern}")

        if score > 0:
            scores[nous_id] = {
                "score": score,
                "matched": matched,
                "epistemology": config["epistemology"],
                "description": config["description"],
            }

    # Sort by score descending
    ranked = sorted(scores.items(), key=lambda x: x[1]["score"], reverse=True)
    return ranked


def recommend(task: str) -> dict:
    """Recommend a team for a task."""
    ranked = score_nous(task)

    if not ranked:
        return {
            "team": [],
            "rationale": "No domain-specific nous matched. Syn handles directly.",
            "mode": "direct",
        }

    # Top scorer is primary
    primary = ranked[0]

    # Include others with score >= 50% of primary
    threshold = primary[1]["score"] * 0.5
    team = [r for r in ranked if r[1]["score"] >= threshold]

    if len(team) == 1:
        mode = "delegate"
        rationale = f"Single-domain task → {team[0][0]} ({team[0][1]['epistemology']})"
    elif len(team) <= 3:
        mode = "deliberate"
        rationale = f"Multi-perspective task → deliberation between {', '.join(t[0] for t in team)}"
    else:
        # Cap at top 3
        team = team[:3]
        mode = "deliberate"
        rationale = f"Complex task → top 3: {', '.join(t[0] for t in team)}"

    return {
        "team": [{"nous": t[0], **t[1]} for t in team],
        "rationale": rationale,
        "mode": mode,
    }


def main():
    parser = argparse.ArgumentParser(description="Dynamic agent composition")
    parser.add_argument("task", help="Task description")
    parser.add_argument("--execute", action="store_true", help="Spawn agents")
    parser.add_argument("--deliberate", action="store_true", help="Run deliberation")
    parser.add_argument("--json", action="store_true", help="JSON output")
    args = parser.parse_args()

    result = recommend(args.task)

    if args.json:
        print(json.dumps(result, indent=2))
    else:
        print(f"Task: {args.task}")
        print(f"Mode: {result['mode']}")
        print(f"Rationale: {result['rationale']}")
        if result["team"]:
            print(f"\nTeam:")
            for member in result["team"]:
                print(f"  {member['nous']} (score: {member['score']}, lens: {member['epistemology']})")
                print(f"    {member['description']}")
                print(f"    Matched: {', '.join(member['matched'])}")


if __name__ == "__main__":
    main()
