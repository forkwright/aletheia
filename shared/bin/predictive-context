#!/bin/bash
source /mnt/ssd/aletheia/shared/config/aletheia.env 2>/dev/null || true
# predictive-context - Preload relevant context based on calendar and patterns
# Run during heartbeats to warm up context before it's needed

set -uo pipefail

SHARED_DIR="${ALETHEIA_SHARED:-${ALETHEIA_ROOT:-/mnt/ssd/aletheia}/shared}"
CLAWD_DIR="${ALETHEIA_NOUS:-${ALETHEIA_ROOT:-/mnt/ssd/aletheia}/nous}/syn"
CACHE_DIR="$SHARED_DIR/cache/predictive"
STATE_FILE="$CACHE_DIR/state.json"

mkdir -p "$CACHE_DIR"

# Initialize state if needed
[[ ! -f "$STATE_FILE" ]] && echo '{"last_run":null,"preloaded":[]}' > "$STATE_FILE"

log() {
    echo "[$(date +%H:%M:%S)] $*"
}

# Get upcoming calendar events
get_upcoming_events() {
    local hours="${1:-4}"
    
    # Use gcal to get events
    if command -v gcal &>/dev/null; then
        gcal events -c user@example.com -d 1 2>/dev/null | head -10
    fi
}

# Extract keywords from calendar event
extract_keywords() {
    local event="$1"
    
    # Known keyword mappings
    declare -A KEYWORD_DOMAINS=(
        ["employer"]="chiron work sql dashboard"
        ["mba"]="eiron school homework capstone"
        ["mba_program"]="eiron school mba"
        ["meeting"]="work chiron"
        ["class"]="eiron school"
        ["homework"]="eiron school"
        ["leather"]="demiurge craft ardent"
        ["partner"]="syl family home"
        ["doctor"]="syl personal health"
        ["dentist"]="syl personal health"
    )
    
    local event_lower=$(echo "$event" | tr '[:upper:]' '[:lower:]')
    
    for keyword in "${!KEYWORD_DOMAINS[@]}"; do
        if [[ "$event_lower" == *"$keyword"* ]]; then
            echo "${KEYWORD_DOMAINS[$keyword]}"
            return
        fi
    done
}

# Preload context for a domain
preload_domain_context() {
    local domain="$1"
    local cache_file="$CACHE_DIR/${domain}_context.md"
    
    log "Preloading context for: $domain"
    
    case "$domain" in
        "chiron"|"work")
            {
                echo "# Work Context (Preloaded)"
                echo ""
                echo "## Recent Work Facts"
                grep -i "employer\|work\|sql\|dashboard" "$SHARED_DIR/memory/facts.jsonl" 2>/dev/null | \
                    jq -r '"- " + .subject + " " + .predicate + ": " + .object' 2>/dev/null | head -10
                echo ""
                echo "## Recent Work Memory"
                cat "$CLAWD_DIR/agent-status/chiron.md" 2>/dev/null | head -30
            } > "$cache_file"
            ;;
        "eiron"|"school")
            {
                echo "# School Context (Preloaded)"
                echo ""
                echo "## Recent School Facts"
                grep -i "mba\|school\|homework\|capstone\|mba_program" "$SHARED_DIR/memory/facts.jsonl" 2>/dev/null | \
                    jq -r '"- " + .subject + " " + .predicate + ": " + .object' 2>/dev/null | head -10
                echo ""
                echo "## MBA Status"
                mba status 2>/dev/null | head -20 || echo "MBA status unavailable"
            } > "$cache_file"
            ;;
        "syl"|"family"|"home")
            {
                echo "# Home/Family Context (Preloaded)"
                echo ""
                echo "## Family Facts"
                grep -i "partner\|family\|home\|personal" "$SHARED_DIR/memory/facts.jsonl" 2>/dev/null | \
                    jq -r '"- " + .subject + " " + .predicate + ": " + .object' 2>/dev/null | head -10
            } > "$cache_file"
            ;;
        "demiurge"|"craft")
            {
                echo "# Craft Context (Preloaded)"
                echo ""
                echo "## Craft Facts"
                grep -i "leather\|craft\|ardent\|making" "$SHARED_DIR/memory/facts.jsonl" 2>/dev/null | \
                    jq -r '"- " + .subject + " " + .predicate + ": " + .object' 2>/dev/null | head -10
            } > "$cache_file"
            ;;
    esac
    
    [[ -f "$cache_file" ]] && log "Cached to: $cache_file ($(wc -c < "$cache_file") bytes)"
}

# Check time of day patterns
check_time_patterns() {
    local hour=$(date +%H)
    
    # Morning (6-9): Likely personal/planning
    if [[ $hour -ge 6 && $hour -lt 9 ]]; then
        echo "morning routine personal planning"
    fi
    
    # Work hours (9-17 weekdays)
    local dow=$(date +%u)
    if [[ $hour -ge 9 && $hour -lt 17 && $dow -le 5 ]]; then
        echo "work chiron"
    fi
    
    # Evening (18-22): Personal, craft, family
    if [[ $hour -ge 18 && $hour -lt 22 ]]; then
        echo "personal family craft"
    fi
}

# Main predictive logic
main() {
    log "=== Predictive Context Loading ==="
    
    local domains_to_preload=()
    
    # 1. Check calendar events
    log "Checking calendar..."
    local events=$(get_upcoming_events 4)
    if [[ -n "$events" ]]; then
        log "Found upcoming events"
        while IFS= read -r event; do
            local keywords=$(extract_keywords "$event")
            if [[ -n "$keywords" ]]; then
                for kw in $keywords; do
                    domains_to_preload+=("$kw")
                done
            fi
        done <<< "$events"
    fi
    
    # 2. Check time-of-day patterns
    log "Checking time patterns..."
    local time_domains=$(check_time_patterns)
    for domain in $time_domains; do
        domains_to_preload+=("$domain")
    done
    
    # 3. Deduplicate and preload
    local unique_domains=($(printf '%s\n' "${domains_to_preload[@]}" | sort -u))
    
    if [[ ${#unique_domains[@]} -eq 0 ]]; then
        log "No specific domains to preload, using defaults"
        unique_domains=("work" "personal")
    fi
    
    log "Preloading domains: ${unique_domains[*]}"
    
    for domain in "${unique_domains[@]}"; do
        preload_domain_context "$domain"
    done
    
    # Update state
    local now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    jq --arg now "$now" --arg domains "${unique_domains[*]}" \
        '.last_run = $now | .preloaded = ($domains | split(" "))' \
        "$STATE_FILE" > "${STATE_FILE}.tmp" && mv "${STATE_FILE}.tmp" "$STATE_FILE"
    
    log "=== Done ==="
    log "Preloaded ${#unique_domains[@]} domain contexts"
}

main "$@"
