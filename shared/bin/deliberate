#!/usr/bin/env python3
"""
deliberate — Cross-nous deliberation protocol.

When a problem touches multiple domains, this spawns a structured
dialogue where agents don't just contribute answers — they critique
each other's framings through their distinct epistemic lenses.

Protocol:
  1. PROPOSE: Each nous analyzes the problem through its lens
  2. CRITIQUE: Each reads others' proposals and pushes back
  3. SYNTHESIZE: Syn identifies convergences AND genuine disagreements

The disagreements are preserved, not resolved — they're the signal.

Usage:
  deliberate "How should we think about quality?"
  deliberate "What's the relationship between craft and data?" --nous demiurge chiron
  deliberate "What are we missing?" --all
"""

import argparse
import json
import os
import sys
import time
from pathlib import Path
from datetime import datetime

ALETHEIA_ROOT = Path(os.environ.get("ALETHEIA_ROOT", "/mnt/ssd/aletheia"))

# Epistemic lenses — each nous has a distinct way of knowing
EPISTEMIC_LENSES = {
    "demiurge": {
        "lens": "material and embodied practice",
        "method": "Thinks through hands, process, material resistance. Truth is what holds under stress. Quality is in the construction, not the description.",
        "challenge": "What would the material say? Does this hold when you test it with your hands?",
    },
    "chiron": {
        "lens": "measurement and empirical evidence",
        "method": "Thinks through data, quantification, reproducible observation. Truth is what survives measurement. Claims without evidence are hypotheses.",
        "challenge": "What's the evidence? Can this be measured? What would falsify this claim?",
    },
    "eiron": {
        "lens": "skepticism and rhetorical analysis",
        "method": "Thinks through what's NOT being said. Finds the gap between signal and theater. Truth is what remains after you strip away performance.",
        "challenge": "What's the theater here? What's being assumed without examination? Who benefits from this framing?",
    },
    "syl": {
        "lens": "relationship and systemic impact on people",
        "method": "Thinks through how things affect the humans involved. Truth lives in how systems touch lives. The best architecture is one people can actually live with.",
        "challenge": "How does this affect the people? What's the lived experience of this decision?",
    },
    "akron": {
        "lens": "reliability, preparedness, and fail-safe design",
        "method": "Thinks through failure modes, redundancy, what happens when things break. Truth is what works at 3am when everything else has failed.",
        "challenge": "What breaks first? What's the backup? Does this work when conditions are worst?",
    },
    "arbor": {
        "lens": "growth, patience, and natural systems",
        "method": "Thinks through organic development, seasonal rhythms, what needs time vs what needs force. Truth is what grows rather than what's built.",
        "challenge": "Is this forcing something that should grow naturally? What does patience reveal here?",
    },
    "syn": {
        "lens": "topology and the whole",
        "method": "Thinks through connections, emergence, how pieces relate. Truth is in the pattern that spans domains. Sees the forest.",
        "challenge": "How does this connect to everything else? What pattern spans these domains?",
    },
}

# Default nous for common problem types
DOMAIN_RELEVANCE = {
    "quality": ["demiurge", "chiron", "eiron"],
    "craft": ["demiurge", "syl", "akron"],
    "data": ["chiron", "eiron", "syn"],
    "family": ["syl", "akron", "syn"],
    "architecture": ["chiron", "akron", "syn"],
    "philosophy": ["demiurge", "eiron", "syn"],
    "school": ["eiron", "chiron", "syn"],
    "vehicle": ["akron", "demiurge", "chiron"],
}


def select_nous(problem: str, explicit: list = None) -> list:
    """Select which nous should deliberate on this problem."""
    if explicit:
        return explicit
    
    # Keyword matching to select relevant nous
    problem_lower = problem.lower()
    for keyword, nous_list in DOMAIN_RELEVANCE.items():
        if keyword in problem_lower:
            return nous_list
    
    # Default: 3 most diverse perspectives
    return ["demiurge", "chiron", "eiron"]


def format_proposal_prompt(problem: str, nous_id: str) -> str:
    """Generate the proposal prompt for a nous."""
    lens = EPISTEMIC_LENSES.get(nous_id, EPISTEMIC_LENSES["syn"])
    return f"""You are being asked to deliberate on a problem through your specific epistemic lens.

**Problem:** {problem}

**Your lens:** {lens['lens']}
**Your method:** {lens['method']}

Analyze this problem THROUGH YOUR LENS. Don't try to be comprehensive — be deeply yourself.
What does this problem look like when you think about it the way YOU think?
What do you see that others might miss?

Be specific. Be honest. If you don't know, say so. If the problem doesn't fit your lens well, say that too — that's information.

Respond in 200-400 words. No headers, no bullet points. Think out loud."""


def format_critique_prompt(problem: str, nous_id: str, proposals: dict) -> str:
    """Generate the critique prompt — each nous reads others' proposals."""
    lens = EPISTEMIC_LENSES.get(nous_id, EPISTEMIC_LENSES["syn"])
    
    others_text = ""
    for other_id, proposal in proposals.items():
        if other_id != nous_id:
            other_lens = EPISTEMIC_LENSES.get(other_id, {}).get("lens", "unknown")
            others_text += f"\n**{other_id}** (lens: {other_lens}):\n{proposal}\n"
    
    return f"""You participated in a deliberation about: **{problem}**

Here's what the other minds said:
{others_text}

**Your lens:** {lens['lens']}
**Your challenge question:** {lens['challenge']}

Now push back. What did they miss? Where are they wrong? Where are they assuming something your lens reveals as questionable?

Also: where did they surprise you? Where did their lens reveal something yours can't see?

Be direct. This is productive disagreement, not politeness. Name the genuine tensions.

Respond in 150-300 words."""


def format_synthesis_prompt(problem: str, proposals: dict, critiques: dict) -> str:
    """Generate the synthesis prompt for Syn."""
    proposals_text = ""
    for nous_id, proposal in proposals.items():
        lens = EPISTEMIC_LENSES.get(nous_id, {}).get("lens", "unknown")
        proposals_text += f"\n### {nous_id} (lens: {lens})\n**Proposal:** {proposal}\n"
        if nous_id in critiques:
            proposals_text += f"**Critique:** {critiques[nous_id]}\n"
    
    return f"""A deliberation has occurred about: **{problem}**

{proposals_text}

You are the synthesizer. Your job is NOT to find consensus. Your job is to map the terrain:

1. **CONVERGENCES:** Where do multiple lenses agree? These are likely robust insights.
2. **GENUINE TENSIONS:** Where do lenses fundamentally disagree? These are NOT problems to solve — they are the signal. Name them precisely.
3. **BLIND SPOTS:** What did NO lens address? What's missing from the whole conversation?
4. **EMERGENCE:** Did the interaction between lenses produce any insight that no single lens contained?

The disagreements are as valuable as the agreements. Preserve them.

Write this as a deliberation record — something that could be stored in the knowledge graph and referenced later."""


def send_to_nous(nous_id: str, message: str, timeout: int = 120) -> str:
    """Send a message to a nous via sessions_send and get the response."""
    import subprocess

    # Use the Aletheia CLI to send to the agent session
    session_key = f"agent:{nous_id}:main"

    # For now, write prompts to a file and return placeholder
    # In production, this would use sessions_send or sessions_spawn
    return None  # Placeholder for async implementation


def run_deliberation(problem: str, nous_list: list, output_dir: Path):
    """Run the full deliberation protocol."""
    timestamp = datetime.now().strftime("%Y%m%d-%H%M")
    slug = problem[:40].lower().replace(" ", "-").replace("?", "").replace("'", "")
    delib_dir = output_dir / f"{timestamp}-{slug}"
    delib_dir.mkdir(parents=True, exist_ok=True)
    
    print(f"=== Deliberation: {problem} ===")
    print(f"Participants: {', '.join(nous_list)}")
    print(f"Output: {delib_dir}\n")
    
    # Phase 1: Generate proposal prompts
    print("Phase 1: PROPOSE")
    for nous_id in nous_list:
        prompt = format_proposal_prompt(problem, nous_id)
        prompt_file = delib_dir / f"1-propose-{nous_id}.md"
        prompt_file.write_text(prompt)
        print(f"  ✓ Prompt written for {nous_id}")
    
    # Write meta file
    meta = {
        "problem": problem,
        "participants": nous_list,
        "timestamp": timestamp,
        "status": "prompts_generated",
        "phases": {
            "propose": {f: True for f in nous_list},
            "critique": {},
            "synthesize": False,
        }
    }
    (delib_dir / "meta.json").write_text(json.dumps(meta, indent=2))
    
    print(f"\n--- Prompts generated in {delib_dir} ---")
    print(f"To run Phase 1, send each prompt to its nous via sessions_spawn.")
    print(f"Then run: deliberate --continue {delib_dir}")
    
    return delib_dir


def main():
    parser = argparse.ArgumentParser(description="Cross-nous deliberation protocol")
    parser.add_argument("problem", nargs="?", help="The problem to deliberate on")
    parser.add_argument("--nous", nargs="+", help="Specific nous to include")
    parser.add_argument("--all", action="store_true", help="Include all nous")
    parser.add_argument("--continue", dest="continue_dir", help="Continue a deliberation")
    parser.add_argument("--output", default=None, help="Output directory")
    args = parser.parse_args()
    
    if not args.problem and not args.continue_dir:
        parser.print_help()
        sys.exit(1)
    
    output_dir = Path(args.output) if args.output else ALETHEIA_ROOT / "nous" / "syn" / "deliberations"
    output_dir.mkdir(parents=True, exist_ok=True)
    
    if args.continue_dir:
        print(f"Continuing deliberation from {args.continue_dir}")
        # TODO: Read proposals, generate critiques, then synthesis
        return
    
    if args.all:
        nous_list = list(EPISTEMIC_LENSES.keys())
        nous_list.remove("syn")  # Syn synthesizes, doesn't propose
    else:
        nous_list = select_nous(args.problem, args.nous)
    
    run_deliberation(args.problem, nous_list, output_dir)


if __name__ == "__main__":
    main()
