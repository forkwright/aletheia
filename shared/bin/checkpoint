#!/usr/bin/env python3
"""
checkpoint — Last-known-good state management for Aletheia.

Saves/restores critical config and runtime state so the watchdog
can automatically revert to a working state after a bad change.

Usage:
    checkpoint save [--label LABEL]    # Snapshot current state
    checkpoint restore [--label LABEL] # Revert to last good state
    checkpoint list                    # Show available checkpoints
    checkpoint verify                  # Check if current state is healthy
"""

import argparse
import hashlib
import json
import os
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path

ALETHEIA_ROOT = Path(os.environ.get("ALETHEIA_ROOT", "/mnt/ssd/aletheia"))
CHECKPOINT_DIR = ALETHEIA_ROOT / "shared" / "checkpoints"
MAX_CHECKPOINTS = 10

# Files that constitute "system state"
CRITICAL_FILES = [
    Path.home() / ".aletheia" / "aletheia.json",
    ALETHEIA_ROOT / "shared" / "config" / "aletheia.env",
]

# Directories to snapshot (shallow — just file list + hashes)
CRITICAL_DIRS = [
    ALETHEIA_ROOT / "shared" / "bin",
]

# Services to check
SERVICES = ["aletheia"]


def file_hash(path: Path) -> str:
    """SHA256 of a file."""
    if not path.exists():
        return "MISSING"
    return hashlib.sha256(path.read_bytes()).hexdigest()[:16]


def dir_manifest(dirpath: Path) -> dict:
    """Hash manifest for a directory."""
    manifest = {}
    if not dirpath.exists():
        return manifest
    for f in sorted(dirpath.iterdir()):
        if f.is_file():
            manifest[f.name] = file_hash(f)
    return manifest


def check_health() -> dict:
    """Check if the system is currently healthy."""
    health = {"healthy": True, "checks": {}}

    # 1. Gateway process running?
    try:
        result = subprocess.run(
            ["pgrep", "-f", "aletheia"],
            capture_output=True, timeout=5
        )
        running = result.returncode == 0
        health["checks"]["gateway_process"] = running
        if not running:
            health["healthy"] = False
    except Exception:
        health["checks"]["gateway_process"] = False
        health["healthy"] = False

    # 2. Gateway responds to health check?
    try:
        result = subprocess.run(
            ["curl", "-sf", "--max-time", "5",
             "http://localhost:18789/health"],
            capture_output=True, timeout=10
        )
        responds = result.returncode == 0
        health["checks"]["gateway_http"] = responds
        if not responds:
            health["healthy"] = False
    except Exception:
        health["checks"]["gateway_http"] = False
        health["healthy"] = False

    # 3. Config parses?
    config_path = Path.home() / ".aletheia" / "aletheia.json"
    try:
        with open(config_path) as f:
            json.load(f)
        health["checks"]["config_valid"] = True
    except Exception:
        health["checks"]["config_valid"] = False
        health["healthy"] = False

    # 4. Neo4j reachable?
    try:
        result = subprocess.run(
            ["curl", "-sf", "http://localhost:7474"],
            capture_output=True, timeout=10
        )
        health["checks"]["neo4j"] = result.returncode == 0
    except Exception:
        health["checks"]["neo4j"] = False

    # 5. Signal-cli running?
    try:
        result = subprocess.run(
            ["pgrep", "-f", "signal-cli"],
            capture_output=True, timeout=5
        )
        health["checks"]["signal_cli"] = result.returncode == 0
    except Exception:
        health["checks"]["signal_cli"] = False

    return health


def cmd_save(label: str = None):
    """Save current state as a checkpoint."""
    CHECKPOINT_DIR.mkdir(parents=True, exist_ok=True)

    # First verify we're healthy
    health = check_health()
    if not health["healthy"]:
        print(f"WARNING: System is NOT healthy. Saving anyway (might be intentional).")
        print(f"  Checks: {json.dumps(health['checks'], indent=2)}")

    ts = datetime.now().strftime("%Y%m%d-%H%M%S")
    label = label or "auto"
    checkpoint_name = f"{ts}-{label}"
    checkpoint_path = CHECKPOINT_DIR / checkpoint_name
    checkpoint_path.mkdir(parents=True)

    manifest = {
        "timestamp": ts,
        "label": label,
        "healthy": health["healthy"],
        "checks": health["checks"],
        "files": {},
        "dirs": {},
    }

    # Copy critical files
    for fpath in CRITICAL_FILES:
        if fpath.exists():
            dest = checkpoint_path / fpath.name
            shutil.copy2(fpath, dest)
            manifest["files"][str(fpath)] = file_hash(fpath)
        else:
            manifest["files"][str(fpath)] = "MISSING"

    # Save directory manifests (not full copies — just hashes for detection)
    for dirpath in CRITICAL_DIRS:
        manifest["dirs"][str(dirpath)] = dir_manifest(dirpath)

    # Save service state
    manifest["services"] = {}
    for svc in SERVICES:
        try:
            result = subprocess.run(
                ["systemctl", "is-active", svc],
                capture_output=True, timeout=5
            )
            manifest["services"][svc] = result.stdout.decode().strip()
        except Exception:
            manifest["services"][svc] = "unknown"

    # Write manifest
    with open(checkpoint_path / "manifest.json", "w") as f:
        json.dump(manifest, f, indent=2)

    # Prune old checkpoints
    checkpoints = sorted(CHECKPOINT_DIR.iterdir(), reverse=True)
    for old in checkpoints[MAX_CHECKPOINTS:]:
        if old.is_dir():
            shutil.rmtree(old)

    print(f"Checkpoint saved: {checkpoint_name}")
    print(f"  Healthy: {health['healthy']}")
    print(f"  Files: {len([f for f in manifest['files'].values() if f != 'MISSING'])}")
    return checkpoint_name


def cmd_restore(label: str = None):
    """Restore from the most recent healthy checkpoint."""
    if not CHECKPOINT_DIR.exists():
        print("ERROR: No checkpoints exist", file=sys.stderr)
        sys.exit(1)

    checkpoints = sorted(CHECKPOINT_DIR.iterdir(), reverse=True)

    target = None
    for cp in checkpoints:
        manifest_path = cp / "manifest.json"
        if not manifest_path.exists():
            continue
        with open(manifest_path) as f:
            manifest = json.load(f)

        if label and manifest.get("label") != label:
            continue
        if not label and not manifest.get("healthy", False):
            continue
        target = (cp, manifest)
        break

    if not target:
        print("ERROR: No suitable checkpoint found", file=sys.stderr)
        sys.exit(1)

    cp_path, manifest = target
    print(f"Restoring from: {cp_path.name}")
    print(f"  Timestamp: {manifest['timestamp']}")
    print(f"  Label: {manifest['label']}")

    restored = 0
    for fpath_str, expected_hash in manifest["files"].items():
        fpath = Path(fpath_str)
        backup_file = cp_path / fpath.name
        if backup_file.exists():
            current_hash = file_hash(fpath)
            if current_hash != expected_hash:
                shutil.copy2(backup_file, fpath)
                print(f"  Restored: {fpath.name} ({current_hash[:8]} → {expected_hash[:8]})")
                restored += 1
            else:
                print(f"  Unchanged: {fpath.name}")
        elif expected_hash == "MISSING":
            pass
        else:
            print(f"  WARNING: No backup for {fpath.name}")

    print(f"\nRestored {restored} files")
    if restored > 0:
        print("Restart the gateway to apply: sudo systemctl restart aletheia")


def cmd_list():
    """List available checkpoints."""
    if not CHECKPOINT_DIR.exists():
        print("No checkpoints yet. Run: checkpoint save")
        return

    for cp in sorted(CHECKPOINT_DIR.iterdir(), reverse=True):
        manifest_path = cp / "manifest.json"
        if not manifest_path.exists():
            continue
        with open(manifest_path) as f:
            manifest = json.load(f)
        status = "✅" if manifest.get("healthy") else "❌"
        label = manifest.get("label", "?")
        ts = manifest.get("timestamp", "?")
        files = len([v for v in manifest.get("files", {}).values() if v != "MISSING"])
        print(f"  {status} {cp.name} ({files} files)")


def cmd_verify():
    """Check current system health."""
    health = check_health()
    status = "✅ HEALTHY" if health["healthy"] else "❌ UNHEALTHY"
    print(f"System: {status}")
    for check, result in health["checks"].items():
        icon = "✅" if result else "❌"
        print(f"  {icon} {check}")
    return health["healthy"]


def main():
    parser = argparse.ArgumentParser(description="Aletheia checkpoint manager")
    parser.add_argument("command", choices=["save", "restore", "list", "verify"])
    parser.add_argument("--label", "-l", default=None)
    args = parser.parse_args()

    if args.command == "save":
        cmd_save(args.label)
    elif args.command == "restore":
        cmd_restore(args.label)
    elif args.command == "list":
        cmd_list()
    elif args.command == "verify":
        sys.exit(0 if cmd_verify() else 1)


if __name__ == "__main__":
    main()
