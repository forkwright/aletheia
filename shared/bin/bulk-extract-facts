#!/bin/bash
source /mnt/ssd/aletheia/shared/config/aletheia.env 2>/dev/null || true
# bulk-extract-facts - Mine memory files for structured facts
# Extracts facts from daily memory files and adds to facts.jsonl

set -euo pipefail

SHARED_DIR="${ALETHEIA_SHARED:-${ALETHEIA_ROOT:-/mnt/ssd/aletheia}/shared}"
FACTS_FILE="$SHARED_DIR/memory/facts.jsonl"
FACTS_CMD="$SHARED_DIR/bin/facts"

# Patterns to extract (regex -> category mapping)
declare -A PATTERNS=(
    # Preferences
    ["prefers? .+"]="preference"
    ["likes? .+"]="preference"
    ["dislikes? .+"]="preference"
    ["wants? .+"]="preference"
    
    # Decisions
    ["decided .+"]="decision"
    ["chose .+"]="decision"
    ["will use .+"]="decision"
    ["switched to .+"]="decision"
    
    # System/Infrastructure
    ["installed .+"]="system"
    ["configured .+"]="system"
    ["running on .+"]="system"
    ["uses? .+ for"]="system"
    
    # Insights/Learnings
    ["learned .+"]="insight"
    ["realized .+"]="insight"
    ["discovered .+"]="insight"
    ["lesson.+:.+"]="insight"
    
    # Projects
    ["working on .+"]="project"
    ["building .+"]="project"
    ["created .+"]="project"
    
    # People
    ["partner .+"]="person"
    ["the operator .+"]="person"
)

extract_from_line() {
    local line="$1"
    local source_file="$2"
    
    # Skip headers, empty lines, timestamps
    [[ "$line" =~ ^#.*$ ]] && return
    [[ -z "$line" ]] && return
    [[ "$line" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2} ]] && return
    [[ "$line" =~ ^\*\*Time ]] && return
    [[ "$line" =~ ^--- ]] && return
    
    # Clean the line
    line=$(echo "$line" | sed 's/^[*-] //' | sed 's/^\s*//')
    
    # Try to extract subject-predicate-object
    # Pattern: "Subject verb/is/has Object"
    
    # Look for "X is Y" patterns
    if [[ "$line" =~ ^([A-Za-z][A-Za-z0-9_-]+)[[:space:]]+(is|are|was|were|has|have|had)[[:space:]]+(.+)$ ]]; then
        local subject="${BASH_REMATCH[1]}"
        local predicate="${BASH_REMATCH[2]}"
        local object="${BASH_REMATCH[3]}"
        
        # Normalize subject
        subject=$(echo "$subject" | tr '[:upper:]' '[:lower:]')
        
        # Determine category based on content
        local category="insight"
        [[ "$subject" == "the operator" || "$subject" == "partner" ]] && category="person"
        [[ "$object" =~ prefer|like|want ]] && category="preference"
        [[ "$object" =~ install|config|server|system ]] && category="system"
        
        echo "{\"subject\":\"$subject\",\"predicate\":\"$predicate\",\"object\":\"$object\",\"category\":\"$category\",\"source\":\"$source_file\"}"
    fi
    
    # Look for "Learned: X" patterns
    if [[ "$line" =~ [Ll]earned:?[[:space:]]+(.+)$ ]]; then
        local insight="${BASH_REMATCH[1]}"
        echo "{\"subject\":\"system\",\"predicate\":\"learned\",\"object\":\"$insight\",\"category\":\"insight\",\"source\":\"$source_file\"}"
    fi
    
    # Look for "Decided to X" patterns
    if [[ "$line" =~ [Dd]ecided[[:space:]]+(to[[:space:]]+)?(.+)$ ]]; then
        local decision="${BASH_REMATCH[2]}"
        echo "{\"subject\":\"the operator\",\"predicate\":\"decided\",\"object\":\"$decision\",\"category\":\"decision\",\"source\":\"$source_file\"}"
    fi
}

process_file() {
    local file="$1"
    local count=0
    
    while IFS= read -r line; do
        local fact=$(extract_from_line "$line" "$(basename "$file")")
        if [[ -n "$fact" ]]; then
            echo "$fact"
            ((count++))
        fi
    done < "$file"
    
    echo "Processed $(basename "$file"): $count potential facts" >&2
}

main() {
    local workspace="${1:-${ALETHEIA_NOUS:-${ALETHEIA_ROOT:-/mnt/ssd/aletheia}/nous}/syn}"
    local dry_run="${2:-false}"
    local total=0
    local added=0
    
    echo "=== Bulk Fact Extraction ===" >&2
    echo "Workspace: $workspace" >&2
    echo "Dry run: $dry_run" >&2
    echo "" >&2
    
    # Find all daily memory files
    local files=$(find "$workspace/memory" -name "2026-*.md" -type f 2>/dev/null | sort)
    
    if [[ -z "$files" ]]; then
        echo "No memory files found" >&2
        exit 1
    fi
    
    # Collect all potential facts
    local temp_facts=$(mktemp)
    
    for file in $files; do
        process_file "$file" >> "$temp_facts"
    done
    
    total=$(wc -l < "$temp_facts")
    echo "" >&2
    echo "Total potential facts extracted: $total" >&2
    
    if [[ "$dry_run" == "true" ]]; then
        echo "" >&2
        echo "=== Sample Facts (dry run) ===" >&2
        head -20 "$temp_facts"
        rm "$temp_facts"
        exit 0
    fi
    
    # Add facts that don't already exist
    echo "" >&2
    echo "Adding new facts..." >&2
    
    while IFS= read -r fact_json; do
        if [[ -n "$fact_json" ]]; then
            local subject=$(echo "$fact_json" | jq -r '.subject')
            local predicate=$(echo "$fact_json" | jq -r '.predicate')
            local object=$(echo "$fact_json" | jq -r '.object')
            local category=$(echo "$fact_json" | jq -r '.category')
            
            # Check if similar fact exists
            if ! grep -q "\"subject\":\"$subject\".*\"predicate\":\"$predicate\"" "$FACTS_FILE" 2>/dev/null; then
                "$FACTS_CMD" add "$subject" "$predicate" "$object" -c "$category" 2>/dev/null && ((added++)) || true
            fi
        fi
    done < "$temp_facts"
    
    rm "$temp_facts"
    
    echo "" >&2
    echo "=== Summary ===" >&2
    echo "Extracted: $total" >&2
    echo "Added: $added" >&2
    echo "Current total: $(wc -l < "$FACTS_FILE")" >&2
}

main "$@"
