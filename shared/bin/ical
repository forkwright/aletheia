#!/usr/bin/env python3
"""Simple ICS calendar fetcher for Clawdbot - with timezone and recurrence support."""

import argparse
import json
import os
from datetime import datetime, timedelta, date
from urllib.request import urlopen
from zoneinfo import ZoneInfo

from icalendar import Calendar
from dateutil import rrule

CALENDARS_FILE = os.path.expanduser("~/.config/ical-calendars.json")
LOCAL_TZ = ZoneInfo("America/Chicago")  # CST/CDT


def load_calendars():
    """Load saved calendar URLs."""
    if os.path.exists(CALENDARS_FILE):
        with open(CALENDARS_FILE) as f:
            return json.load(f)
    return {}


def save_calendars(calendars):
    """Save calendar URLs."""
    os.makedirs(os.path.dirname(CALENDARS_FILE), exist_ok=True)
    with open(CALENDARS_FILE, "w") as f:
        json.dump(calendars, f, indent=2)


def add_calendar(name, url):
    """Add a calendar URL."""
    calendars = load_calendars()
    calendars[name] = url
    save_calendars(calendars)
    print(f"Added calendar: {name}")


def list_calendars():
    """List saved calendars."""
    calendars = load_calendars()
    if not calendars:
        print("No calendars saved.")
        return
    for name, url in calendars.items():
        print(f"- {name}: {url[:50]}...")


def get_tz_from_tzid(tzid: str) -> ZoneInfo | None:
    """Convert Windows timezone IDs to IANA timezone."""
    # Common mappings for Outlook/Exchange calendars
    tz_map = {
        "Central Standard Time": "America/Chicago",
        "Eastern Standard Time": "America/New_York",
        "Pacific Standard Time": "America/Los_Angeles",
        "Mountain Standard Time": "America/Denver",
        "Romance Standard Time": "Europe/Paris",
        "GMT Standard Time": "Europe/London",
        "Central America Standard Time": "America/Guatemala",
        "Morocco Standard Time": "Africa/Casablanca",
        "Central Standard Time (Mexico)": "America/Mexico_City",
        "UTC": "UTC",
    }
    iana_tz = tz_map.get(tzid, tzid)
    try:
        return ZoneInfo(iana_tz)
    except Exception:
        return None


def to_local_datetime(dt, tzinfo=None) -> datetime:
    """Convert a datetime/date to local timezone datetime."""
    # Handle date objects (all-day events)
    if isinstance(dt, date) and not isinstance(dt, datetime):
        return datetime.combine(dt, datetime.min.time()).replace(tzinfo=LOCAL_TZ)
    
    # If dt already has tzinfo, convert to local
    if dt.tzinfo:
        return dt.astimezone(LOCAL_TZ)
    
    # If we have a tzinfo from the calendar, apply it then convert
    if tzinfo:
        dt = dt.replace(tzinfo=tzinfo)
        return dt.astimezone(LOCAL_TZ)
    
    # Assume it's already local
    return dt.replace(tzinfo=LOCAL_TZ)


def expand_rrule(component, start_dt, end_dt):
    """Expand recurring events within the date range."""
    events = []
    rrule_prop = component.get("rrule")
    if not rrule_prop:
        return events
    
    dtstart = component.get("dtstart")
    if not dtstart:
        return events
    
    dt = dtstart.dt
    tzid = dtstart.params.get("TZID")
    tz = get_tz_from_tzid(tzid) if tzid else None
    
    # Build rrule from the RRULE property
    try:
        rule_str = rrule_prop.to_ical().decode("utf-8")
        rule = rrule.rrulestr(f"RRULE:{rule_str}", dtstart=dt)
        
        # Get excluded dates
        exdates = set()
        for exdate in component.get("exdate", []):
            if hasattr(exdate, "dts"):
                for exdt in exdate.dts:
                    exdates.add(exdt.dt.date() if hasattr(exdt.dt, "date") else exdt.dt)
        
        # Generate occurrences
        summary = str(component.get("summary", "(No title)"))
        dtend = component.get("dtend")
        duration = None
        if dtend:
            duration = dtend.dt - dt
        
        for occurrence in rule.between(start_dt, end_dt, inc=True):
            # Skip excluded dates
            occ_date = occurrence.date() if hasattr(occurrence, "date") else occurrence
            if occ_date in exdates:
                continue
            
            local_dt = to_local_datetime(occurrence, tz)
            events.append((local_dt, summary))
    except Exception:
        # If rrule parsing fails, skip this event
        pass
    
    return events


def fetch_events(name_or_url, days=7):
    """Fetch events from an ICS calendar."""
    calendars = load_calendars()
    
    if name_or_url in calendars:
        url = calendars[name_or_url]
    else:
        url = name_or_url
    
    response = urlopen(url)
    cal = Calendar.from_ical(response.read())
    
    now = datetime.now(LOCAL_TZ)
    # Start from beginning of today
    start = now.replace(hour=0, minute=0, second=0, microsecond=0)
    end = start + timedelta(days=days)
    
    events = []
    seen_uids = {}  # Track UIDs to handle RECURRENCE-ID overrides
    recurrence_overrides = {}  # Track which (uid, original_date) have been overridden
    
    # First pass: collect RECURRENCE-ID overrides
    for component in cal.walk():
        if component.name != "VEVENT":
            continue
        
        recurrence_id = component.get("recurrence-id")
        if not recurrence_id:
            continue
        
        uid = str(component.get("uid", ""))
        
        # Get the original date that's being overridden
        orig_dt = recurrence_id.dt
        tzid = recurrence_id.params.get("TZID")
        tz = get_tz_from_tzid(tzid) if tzid else None
        orig_local = to_local_datetime(orig_dt, tz)
        
        # Mark this (uid, original_date) as overridden
        recurrence_overrides[(uid, orig_local.date())] = True
        
        # Get the NEW time for this event
        dtstart = component.get("dtstart")
        if dtstart:
            dt = dtstart.dt
            tzid = dtstart.params.get("TZID")
            tz = get_tz_from_tzid(tzid) if tzid else None
            local_dt = to_local_datetime(dt, tz)
            
            if start <= local_dt <= end:
                summary = str(component.get("summary", "(No title)"))
                key = (uid, local_dt.date())
                seen_uids[key] = (local_dt, summary)
    
    # Second pass: collect recurring and non-recurring events (skip overridden)
    for component in cal.walk():
        if component.name != "VEVENT":
            continue
        
        uid = str(component.get("uid", ""))
        recurrence_id = component.get("recurrence-id")
        
        # Skip recurrence-id overrides (already handled)
        if recurrence_id:
            continue
        
        # Handle recurring events
        if component.get("rrule"):
            expanded = expand_rrule(component, start, end)
            for dt, summary in expanded:
                key = (uid, dt.date())
                # Skip if this instance was overridden
                if (uid, dt.date()) in recurrence_overrides:
                    continue
                if key not in seen_uids:
                    seen_uids[key] = (dt, summary)
            continue
        
        # Handle single events
        dtstart = component.get("dtstart")
        if dtstart:
            dt = dtstart.dt
            tzid = dtstart.params.get("TZID")
            tz = get_tz_from_tzid(tzid) if tzid else None
            
            local_dt = to_local_datetime(dt, tz)
            
            # Check if in range
            if start <= local_dt <= end:
                summary = str(component.get("summary", "(No title)"))
                key = (uid, local_dt.date())
                if key not in seen_uids:
                    seen_uids[key] = (local_dt, summary)
    
    # Collect all events
    events = list(seen_uids.values())
    events.sort(key=lambda x: x[0])
    
    if not events:
        print(f"No events in the next {days} days.")
        return
    
    for dt, summary in events:
        if dt.hour == 0 and dt.minute == 0:
            time_str = f"{dt.strftime('%Y-%m-%d')} All day"
        else:
            time_str = dt.strftime("%Y-%m-%d %H:%M")
        print(f"{time_str}: {summary}")


def main():
    parser = argparse.ArgumentParser(description="ICS Calendar CLI")
    subparsers = parser.add_subparsers(dest="command", help="Commands")
    
    # add
    add_parser = subparsers.add_parser("add", help="Add a calendar")
    add_parser.add_argument("name", help="Calendar name")
    add_parser.add_argument("url", help="ICS URL")
    
    # list
    subparsers.add_parser("list", help="List saved calendars")
    
    # events
    events_parser = subparsers.add_parser("events", help="Fetch events")
    events_parser.add_argument("calendar", help="Calendar name or URL")
    events_parser.add_argument("--days", "-d", type=int, default=7, help="Days ahead")
    
    args = parser.parse_args()
    
    if args.command == "add":
        add_calendar(args.name, args.url)
    elif args.command == "list":
        list_calendars()
    elif args.command == "events":
        fetch_events(args.calendar, args.days)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
